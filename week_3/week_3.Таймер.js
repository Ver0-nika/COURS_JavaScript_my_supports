/* близкая по теме интересная ссылка "Планирование: setTimeout и setInterval"
https://learn.javascript.ru/settimeout-setinterval
 */
console.log('до setTimeout');
// setTimeout кладет в очередь задачу из его первого параметра и идет дальше не дожидаясь пока эта задача будет выполнена
// интерпретатор не начнет обрабатывать эту очередь пока контекст исполнения (основной поток кода) не выполнится до конца
setTimeout(function (){
    console.log('таймер на 3000 милисекунд');
}, 3000);
setTimeout(function (){
    console.log('таймер на 500 милисекунд = 0,5 секунд');
}, 500);
console.log('после setTimeout');
console.log('до for');
console.time('q'); // для замерки сколько выполняется цикл for
for (let i = 0; i < 2000000000; i++){
    let a = i/i;
}
// таймер на 3000 милисекунд исполнится через 1 сек после for, а не через 3, так как for займет 2 сек
console.timeEnd('q'); // для замерки сколько выполняется цикл for
console.log('после for');
/* результат в консоле : ( выполнение for займет больше времени чем таймер setTimeout но таймер все-равно выполнится ТОЛЬКО ПОСЛЕ него)
* до setTimeout
* после setTimeout
* до for
* q: 1.616s
* после for
* таймер на 500 милисекунд = 0,5 секунд
* таймер на 3000 милисекунд
* */
//--------------------------------------------
// не запускать код ниже, он только для лучшего представления механизма setTimeout
// когда интерпретатор доходит до setTimeout он добавляет в очередь следующий объект
const queue = [
    {
        fn: function (){
            console.log('таймер на 3000 милисекунд'); // тело функции на исполнение по истечении таймера
        },
        delay: 3000, // на сколько отложить выполнение кода
        start: 54675869769 // интерпретатор запоминает время старта (когда он наткнулся на setTimeout)
    },
    {
        fn: function (){
            console.log('таймер на 500 милисекунд');
        },
        delay: 500,
        start: 54675869770
    }
];
